
import gevent
import gevent.monkey ; gevent.monkey.patch_all()

import threading
from array import array
from Queue import Queue

import msgpack


class ClientChannel(object):
    """

    FIXME, fix all the docs

    Channels are connections to another participant. They maintain a
    message queue and push only one at a time.

    A couple implementation notes:

      - We maintain a single connection to the remote end and push all
        messages down this one socket. Calls to req place message
        tuples on a shared queue, and there's a runner thread that
        actually pushes those messages into the socket.

      - Simlarly, there's a receiving thread that deserializes message
        tuples off the socket and then wakes up threads that are
        blocked on a req call. The rep generated by a req is handled
        on the same thread by design.

      - This code assumes the use of gevent cooperative threads, so
        aside from the message queue there's a stunning lack of
        coordination structures.

    """

    REQ_TYPE = 'q'
    REP_TYPE = 'p'

    def __init__(self, sock):
        """Sets up message tuple queue to remote."""

        self._queue = Queue()

        self._sock_lock = threading.Lock()
        self._sock = sock
        self._req_buffer = bytearray(1000000)
        self._req_mv = memoryview(self._req_buffer)

        self._refs = {}
        self._ref_count = 1

        self._MAX_TO_PROCESS = 100

    def req(self, data, timeout):
        """Sends data to the other side and waits for a response.

        If no response within timeout period (or connection failure)
        then raises an error.

        """

        # fixme: handle timeout

        packer = msgpack.Packer()
        unpacker = msgpack.Unpacker()
        with self._sock_lock:
            # fixme: handle some errors here
            #print "sending data", data
            self._sock.sendall(packer.pack(data))
            while True:
                amt = self._sock.recv_into(self._req_buffer, 1000000)
                if not self._req_buffer:
                    raise ValueError("socket closed fixme: raise real error")
                unpacker.feed(self._req_mv[:amt])
                for m in unpacker:
                    # We only expect a single message in response
                    # because of the synchronous pattern from sendall.
                    return m


class ServerChannel(object):
    def __init__(self, sock, rep_handler):
        self._sock = sock
        self._rep_handler = rep_handler

    def start(self):
        packer = msgpack.Packer()
        unpacker = msgpack.Unpacker()
        buf = bytearray(1000000)
        mv = memoryview(buf)
        while True:
            # fixme: switch to buffer object
            #buf = self._sock.recv(1024*1024)
            amt = self._sock.recv_into(buf, 1000000)
            if not buf:
                # fixme: HANDLE THIS
                break

            #print len(buf), buf

            unpacker.feed(mv[:amt])
            for m in unpacker:
                rep = self._rep_handler(m)
                self._sock.sendall(packer.pack(rep)) # fixme: handle error


if __name__ == '__main__':
    import socket
    ch = ClientChannel(socket.create_connection(('localhost', 9090)))
    for i in xrange(100000):
        ch.req("foo", 5.0)
